// Package ec (elliptic curve) provides functionalities to perform operations on elliptic curves.
// These operations include erforming the elliptic curve group operation, scalar multiplication
// of a point on the curve, and fetching the parameters of a predefined elliptic curve.
// This package is useful in the field of elliptic curve cryptography.
// Supported curves: secp192k1, secp192r1, secp224k1, secp224r1, secp256k1, secp256r1, secp384r1, secp521r1
//
//	Reference: https://www.secg.org/sec2-v2.pdf
package ec

import (
	"math/big"
)

// Point structure represents a point on an elliptic curve with coordinates Px and Py.
type Point struct {
	Px, Py *big.Int
}

// EC structure represents the parameters of an elliptic curve: prime number P,
// curve constants A and B, coordinates Gx and Gy of generator point G,
// order of the cyclic subgroup generated by G (N), and cofactor H.
type EC struct {
	P, A, B *big.Int
	Gx, Gy  *big.Int
	N, H    *big.Int
}

// IsPointOnCurve is a method for the EC (elliptic curve) struct.
// It takes a Point P (containing x and y axis coordinates of the point) as an argument.
// It checks whether a point P(x, y) lies on the elliptic curve defined by the equation y**2 = x**3 + a*x + b (mod p).
func (ec *EC) IsPointOnCurve(P Point) {
	// Calculation of (y**2) modulo p.
	// This reflects the left-hand side of the elliptic curve equation.
	ySquaredModP := new(big.Int).Exp(P.Py, big.NewInt(2), ec.P)
	ySquaredModP.Mod(ySquaredModP, ec.P)

	// Calculation of (x**3 + a*x + b) modulo p.
	// This reflects the right-hand side of the elliptic curve equation.
	xCubed := new(big.Int).Exp(P.Px, big.NewInt(3), ec.P)
	ax := new(big.Int).Mul(ec.A, P.Px)
	xCubed.Add(xCubed, ax)
	xCubed.Add(xCubed, ec.B)
	xCubed.Mod(xCubed, ec.P)

	// Comparison of both sides of the equation.
	// If (y**2) modulo p is not equal to (x**3 + a*x + b) modulo p,
	// the function will panic and print the message "Point is NOT on the elliptic curve".
	if ySquaredModP.Cmp(xCubed) != 0 {
		panic("Point is NOT on the elliptic curve")
	}

}

// Dot function returns the result of the elliptic curve group operation between points P and Q.
func (ec *EC) Dot(P, Q Point) Point {

	if P.Px == nil || P.Py == nil {
		return Q
	}

	if Q.Px == nil || Q.Py == nil {
		return P
	}

	if P.Px.Cmp(Q.Px) == 0 && P.Py.Cmp(Q.Py) == 0 {
		ec.IsPointOnCurve(P)
		n := new(big.Int).Mod(new(big.Int).Add(new(big.Int).Mul(new(big.Int).SetInt64(3), new(big.Int).Exp(P.Px, big.NewInt(2), nil)), ec.A), ec.P)
		d := new(big.Int).Mod(new(big.Int).Mul(big.NewInt(2), P.Py), ec.P)

		inv := new(big.Int).ModInverse(d, ec.P)

		if inv == nil {
			return Point{}
		}

		s := new(big.Int).Mod(new(big.Int).Mul(n, inv), ec.P)

		x3 := new(big.Int).Mod(new(big.Int).Sub(new(big.Int).Exp(s, big.NewInt(2), nil), new(big.Int).Add(P.Px, P.Px)), ec.P)

		y3 := new(big.Int).Mod(new(big.Int).Sub(new(big.Int).Mul(s, new(big.Int).Sub(P.Px, x3)), P.Py), ec.P)

		R := Point{
			Px: x3,
			Py: y3,
		}
		ec.IsPointOnCurve(R)
		return R
	}
	ec.IsPointOnCurve(P)
	ec.IsPointOnCurve(Q)
	n := new(big.Int).Mod(new(big.Int).Sub(Q.Py, P.Py), ec.P)
	d := new(big.Int).Mod(new(big.Int).Sub(Q.Px, P.Px), ec.P)

	inv := new(big.Int).ModInverse(d, ec.P)

	if inv == nil {
		return Point{}
	}

	s := new(big.Int).Mod(new(big.Int).Mul(n, inv), ec.P)

	x3 := new(big.Int).Mod(new(big.Int).Sub(new(big.Int).Sub(new(big.Int).Exp(s, big.NewInt(2), nil), P.Px), Q.Px), ec.P)

	y3 := new(big.Int).Mod(new(big.Int).Sub(new(big.Int).Mul(s, new(big.Int).Sub(P.Px, x3)), P.Py), ec.P)

	R := Point{
		Px: x3,
		Py: y3,
	}
	ec.IsPointOnCurve(R)
	return R

}

// Trapdoor function returns point Q, result of the scalar multiplication of point G and
// the integer number (scalar).
func (ec *EC) Trapdoor(G *Point, scalar *big.Int) Point {

	/*
		y^2 = x^3 + 2x + 0 mod 17

		P = (8, 16)

		10P = ?
		10 = bin(1010)

		bit | operation          | result
		1   | ignore             | P
		0   | double             | 2P
		1   | double addition    | 5P
		0   | double             | 10P

		10P = (9, 13)
	*/

	k := new(big.Int).Set(scalar)
	if k.Cmp(big.NewInt(0)) == 0 || k.Cmp(ec.N) >= 0 {
		panic("k is not in 0 < k < n")
	}
	numBits := k.BitLen()
	R := Point{}

	for i := numBits - 1; i >= 0; i-- {
		if R.Px == nil && R.Py == nil {
			R.Px = G.Px
			R.Py = G.Py
			continue
		}
		// if R.Px == nil && R.Py == nil {
		//	 R = *G
		// }
		R = ec.Dot(R, R)
		if new(big.Int).Rsh(k, uint(i)).Bit(0) == 1 {
			if R.Px == nil && R.Py == nil {
				R = *G
			} else {
				R = ec.Dot(R, *G)
			}
		}
	}
	return R
}

// Get function returns the parameters of the elliptic curve specified by the string curve.
// This function covers only a few curves for demonstrative purposes.
func Get(curve string) EC {
	switch curve {

	case "secp192k1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", 16)

		A := new(big.Int)
		A.SetString("0", 16)

		B := new(big.Int)
		B.SetString("3", 16)

		Gx := new(big.Int)
		Gx.SetString("DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", 16)

		Gy := new(big.Int)
		Gy.SetString("9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp192r1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", 16)

		A := new(big.Int)
		A.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", 16)

		B := new(big.Int)
		B.SetString("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", 16)

		Gx := new(big.Int)
		Gx.SetString("188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", 16)

		Gy := new(big.Int)
		Gy.SetString("07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp224k1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D", 16)

		A := new(big.Int)
		A.SetString("0", 16)

		B := new(big.Int)
		B.SetString("5", 16)

		Gx := new(big.Int)
		Gx.SetString("A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C", 16)

		Gy := new(big.Int)
		Gy.SetString("7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5", 16)

		N := new(big.Int)
		N.SetString("010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp224r1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", 16)

		A := new(big.Int)
		A.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", 16)

		B := new(big.Int)
		B.SetString("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", 16)

		Gx := new(big.Int)
		Gx.SetString("B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", 16)

		Gy := new(big.Int)
		Gy.SetString("BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp256k1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16)

		A := new(big.Int)
		A.SetString("0", 16)

		B := new(big.Int)
		B.SetString("7", 16)

		Gx := new(big.Int)
		Gx.SetString("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", 16)

		Gy := new(big.Int)
		Gy.SetString("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16)

		H := new(big.Int)
		H.SetString("0", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp256r1":

		P := new(big.Int)
		P.SetString("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", 16)

		A := new(big.Int)
		A.SetString("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", 16)

		B := new(big.Int)
		B.SetString("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", 16)

		Gx := new(big.Int)
		Gx.SetString("6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", 16)

		Gy := new(big.Int)
		Gy.SetString("4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp384r1":

		P := new(big.Int)
		P.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", 16)

		A := new(big.Int)
		A.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", 16)

		B := new(big.Int)
		B.SetString("B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", 16)

		Gx := new(big.Int)
		Gx.SetString("AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", 16)

		Gy := new(big.Int)
		Gy.SetString("3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F", 16)

		N := new(big.Int)
		N.SetString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}

	case "secp521r1":

		P := new(big.Int)
		P.SetString("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", 16)

		A := new(big.Int)
		A.SetString("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", 16)

		B := new(big.Int)
		B.SetString("0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", 16)

		Gx := new(big.Int)
		Gx.SetString("00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", 16)

		Gy := new(big.Int)
		Gy.SetString("011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650", 16)

		N := new(big.Int)
		N.SetString("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", 16)

		H := new(big.Int)
		H.SetString("1", 16)

		return EC{
			P:  P,
			A:  A,
			B:  B,
			Gx: Gx,
			Gy: Gy,
			N:  N,
			H:  H,
		}
	default:
		// Returns an unrecognized curve
		return EC{}
	}
}
